from fastapi import FastAPI
from pydantic import BaseModel
from sqlalchemy import Column, Integer, String
from sqlalchemy import Enum
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session
from sqlalchemy.orm import sessionmaker

# Создаем объект класса FastAPI
app = FastAPI()

# Создаем движок для подключения к SQLite базе данных
DATABASE_URL = "sqlite:///./cinema.db"
engine = create_engine(DATABASE_URL)

# Определяем базовый класс для объявления моделей
Base = declarative_base()


# Определяем модель для таблицы actors
class Actor(Base):
    __tablename__ = "actors"

    id = Column(Integer, primary_key=True, index=True)
    actor_id = Column(Integer)
    name = Column(String(20))
    surname = Column(String(20))
    age = Column(Integer)
    sex = Column(Enum("male", "female"))


# Создаем таблицы
Base.metadata.create_all(bind=engine)

# Создаем сессию для работы с базой данных
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


# Определяем модель для данных об актере
class Actor(BaseModel):
    actor_id: int
    name: str
    surname: str
    age: int
    sex: str


# Создаем сессию для работы с базой данных
DATABASE_URL = "sqlite:///./cinema.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


# Эндпоинт с POST запросом для сохранения данных об актере в базу данных
class ActorDB:
    pass


@app.post("/create_actor/")
async def create_actor(actor: Actor, db: Session = SessionLocal):
    db_actor = ActorDB(**actor.dict())
    db.add(db_actor)
    db.commit()
    db.refresh(db_actor)
    return db_actor
